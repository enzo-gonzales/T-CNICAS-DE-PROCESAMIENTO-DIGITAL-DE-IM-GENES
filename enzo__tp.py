# -*- coding: utf-8 -*-
"""Enzo _TP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fhsl5CuDJAfBFAv-s4xH9jRtWZQozy38

# TRABAJO PR√ÅCTICO INTEGRADOR N¬∞1

## Sistema de An√°lisis de Documentos Digitalizados

---

**Informaci√≥n del Estudiante:**
- **Nombre y Apellido:** [COMPLETAR]
- **Fecha de Entrega:** 24 de Septiembre de 2025
- **Materia:** Procesamiento de Im√°genes - IFTS24

---

### Objetivo

Desarrollar un sistema b√°sico de an√°lisis autom√°tico de documentos digitalizados que integre las t√©cnicas de procesamiento de im√°genes estudiadas en el curso.

### Estructura del Trabajo

| Parte | Descripci√≥n | Peso |
|-------|-------------|------|
| **1** | Fundamentos Te√≥ricos | 20% |
| **2** | Setup del Entorno | 15% |
| **3** | An√°lisis de Im√°genes | 35% |
| **4** | Preprocessing B√°sico | 30% |

**Dataset requerido:** 3 im√°genes de documentos con diferentes caracter√≠sticas (buena calidad, rotada, con problemas de iluminaci√≥n)

---

# PARTE 1: Fundamentos Te√≥ricos

## ¬øPor qu√© Cuadernos Interactivos para IA y Ciencias de Datos?

### Diferencias Metodol√≥gicas Fundamentales

El trabajo en inteligencia artificial y ciencias de datos requiere un enfoque metodol√≥gico diferente al desarrollo de software tradicional. Mientras que la programaci√≥n tradicional sigue un flujo lineal y predecible, el trabajo con datos es inherentemente iterativo y exploratorio.

**Programaci√≥n Tradicional:**
```
Requisitos ‚Üí Dise√±o ‚Üí Implementaci√≥n ‚Üí Testing ‚Üí Producto
```

**Investigaci√≥n en IA/Datos:**
```
Hip√≥tesis ‚ü∑ Experimento ‚ü∑ An√°lisis ‚ü∑ Refinamiento ‚ü∑ Nueva Hip√≥tesis
```

### Ventajas de los Cuadernos Interactivos

1. **Narrativa Cient√≠fica:** Permiten documentar el proceso de pensamiento, no solo el resultado final
2. **Iteraci√≥n R√°pida:** Ejecutar y modificar secciones espec√≠ficas sin reejecutar todo el programa
3. **Visualizaci√≥n Inmediata:** Ver resultados inmediatamente despu√©s de cada paso
4. **Comunicaci√≥n Efectiva:** Stakeholders no t√©cnicos pueden seguir el proceso y entender decisiones
5. **Reproducibilidad:** Otros investigadores pueden replicar exactamente los experimentos

### Casos de Uso en la Industria

- **Google Research:** Publica papers con cuadernos que permiten reproducir experimentos
- **Netflix:** Usa cuadernos para an√°lisis de datos de usuarios y recomendaciones
- **Uber:** An√°lisis de patrones de viajes y optimizaci√≥n de rutas
- **Kaggle:** Plataforma completa basada en cuadernos para competencias de machine learning

### Cu√°ndo Usar Cada Herramienta

**Usar Cuadernos para:**
- An√°lisis exploratorio de datos
- Experimentaci√≥n y prototipado
- Comunicaci√≥n de resultados
- Educaci√≥n y documentaci√≥n

**Usar Scripts para:**
- Sistemas en producci√≥n
- Automatizaci√≥n de tareas repetitivas
- APIs y servicios web
- Pipelines de datos automatizados

En este trabajo pr√°ctico, usaremos cuadernos porque estamos en la fase de investigaci√≥n y experimentaci√≥n, donde necesitamos entender los datos, probar diferentes enfoques y documentar nuestros hallazgos.

---

# PARTE 2: Setup del Entorno

En esta secci√≥n vas a configurar tu entorno de trabajo de manera profesional. Un setup bien hecho te ahorra tiempo y errores durante todo el proyecto.

**Material de consulta:** `Utilidades_y_Plantillas.ipynb`

## 2.1 Importaciones B√°sicas

Import√° las librer√≠as necesarias para procesamiento de im√°genes y visualizaci√≥n:
"""

# Commented out IPython magic to ensure Python compatibility.
# Import√° aqu√≠ las librer√≠as necesarias
# Necesitar√°s: numpy, matplotlib, opencv, y configuraciones b√°sicas
#------------------------------------------------------------------#
import numpy as np                     # Para operaciones num√©ricas y matrices
import matplotlib.pyplot as plt        # Para mostrar im√°genes y gr√°ficos
import cv2                             # OpenCV: procesamiento de im√°genes

#  Configuraciones b√°sicas


# %matplotlib inline

# Cambiar estilo de gr√°ficos (opcional)
plt.style.use('seaborn-v0_8')

"""## 2.2 Funciones Utilitarias

Implement√° una funci√≥n b√°sica para cargar y mostrar informaci√≥n de im√°genes:
"""

def cargar_imagen(ruta):
    """
    Carga una imagen desde una ruta y la convierte a RGB.
    Devuelve None si hay error.
    """
    imagen = cv2.imread(ruta)  # Leer imagen
    if imagen is None:
        print(f"‚ö†Ô∏è No se pudo cargar la imagen: {ruta}")
        return None

    imagen_rgb = cv2.cvtColor(imagen, cv2.COLOR_BGR2RGB)  # Convertir a RGB
    return imagen_rgb


def mostrar_info_imagen(imagen, titulo="Imagen"):
    """
    Muestra dimensiones, tipo, rango de valores y visualiza la imagen.
    """
    if imagen is None:
        print("‚ö†Ô∏è Imagen no v√°lida")
        return

    print("üìê Dimensiones:", imagen.shape)
    print("üî¢ Tipo:", imagen.dtype)
    print("üåà Rango:", imagen.min(), "-", imagen.max())

    plt.imshow(imagen)
    plt.title(titulo)
    plt.axis('off')
    plt.show()


# üß™ Uso del programa
# Cambia "imagen.jpg" por la ruta de tu archivo
ruta_imagen = "imagen.jpg"

# Cargar la imagen en una variable
imagen = cargar_imagen(ruta_imagen)

# Mostrar informaci√≥n y la imagen
mostrar_info_imagen(imagen, "Imagen cargada")

"""## 2.3 Verificaci√≥n del Setup

Prob√° que todo funciona creando una imagen sint√©tica simple:
"""

# Cre√° una imagen sint√©tica simple (ej: gradiente o patr√≥n)
# Prob√° tus funciones con esta imagen

"""---

# PARTE 3: An√°lisis de Tu Dataset

Ahora vas a trabajar con tu dataset de 3 documentos. Esta parte es clave para entender qu√© problemas ten√©s que resolver.

**Preparaci√≥n del Dataset:**
- Cre√° una carpeta llamada `dataset/` en la misma ubicaci√≥n que este notebook
- Inclu√≠ exactamente 3 im√°genes de documentos:
  1. Una de buena calidad (bien iluminada, recta)
  2. Una rotada o inclinada
  3. Una con problemas (oscura, borrosa, o con sombras)

## 3.1 Carga de las Im√°genes

**Material de consulta:** `002/TEO/LeerImagenColor.ipynb`
"""

# Define las rutas a tus 3 im√°genes
rutas_imagenes = [
    "dataset/imagen1.jpg",  # Buena calidad
    "dataset/imagen2.jpg",  # Rotada
    "dataset/imagen3.jpg"   # Con problemas
]

# Carga las 3 im√°genes usando tu funci√≥n
imagenes = []
nombres = ["Buena Calidad", "Rotada", "Con Problemas"]

# ‚úÖ Cargar cada imagen en la lista
for ruta in rutas_imagenes:
    img = cargar_imagen(ruta)
    imagenes.append(img)

# ‚úÖ Mostrar informaci√≥n de cada imagen
for img, nombre in zip(imagenes, nombres):
    mostrar_info_imagen(img, nombre)

"""## 3.2 Inspecci√≥n Visual y An√°lisis

**Material de consulta:** `002/Fundamentos_Imagen_Digital.ipynb`
"""

# Mostrar las 3 im√°genes lado a lado con sus nombres
# Usa subplots de matplotlib

fig, axs = plt.subplots(1, 3, figsize=(15, 5))  # 1 fila, 3 columnas

for i, (img, nombre) in enumerate(zip(imagenes, nombres)):
    axs[i].imshow(img)
    axs[i].set_title(nombre)
    axs[i].axis('off')  # Oculta los ejes para mejor visualizaci√≥n

plt.tight_layout()
plt.show()

# Mostrar informaci√≥n b√°sica y el histograma de cada imagen

for img, nombre in zip(imagenes, nombres):
    if img is None:
        print(f"‚ö†Ô∏è No se pudo procesar la imagen: {nombre}")
        continue

    # --- Informaci√≥n b√°sica ---
    print(f"üîé An√°lisis de: {nombre}")
    mostrar_info_imagen(img, nombre)  # Usa la funci√≥n que hicimos antes

    # --- Histograma ---
    # Si la imagen es a color, la convertimos a escala de grises para el histograma
    if len(img.shape) == 3:
        img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    else:
        img_gray = img

    plt.figure(figsize=(6, 4))
    plt.hist(img_gray.ravel(), bins=256, color='gray', alpha=0.8)
    plt.title(f"Histograma - {nombre}")
    plt.xlabel("Valor de intensidad")
    plt.ylabel("Frecuencia")
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()

"""## 3.3 Identificaci√≥n de Problemas

Bas√°ndote en tu inspecci√≥n visual, identific√° los problemas principales de cada imagen:

**Imagen 1 (Buena Calidad):**
- Problemas identificados: [COMPLETAR]
- Preprocessing necesario: [COMPLETAR]

**Imagen 2 (Rotada):**
- Problemas identificados: [COMPLETAR]
- Preprocessing necesario: [COMPLETAR]

**Imagen 3 (Con Problemas):**
- Problemas identificados: [COMPLETAR]
- Preprocessing necesario: [COMPLETAR]

---

# PARTE 4: Preprocessing B√°sico

Ahora vas a aplicar t√©cnicas de preprocessing para mejorar cada imagen. Trabaj√° con una imagen por vez.

## 4.1 Segmentaci√≥n B√°sica

Separar el documento del fondo es el primer paso cr√≠tico.

**Material de consulta:** `Segmentacion.ipynb` (especialmente las funciones de umbralizaci√≥n)
"""

# Eleg√≠ UNA de tus im√°genes para trabajar primero
imagen_trabajo = imagenes[0]  # Cambi√° el √≠ndice (0, 1 o 2) seg√∫n la imagen que quieras

# ‚úÖ Convertir a escala de grises
imagen_gris = cv2.cvtColor(imagen_trabajo, cv2.COLOR_RGB2GRAY)

# Mostrar resultado
plt.imshow(imagen_gris, cmap='gray')
plt.title("Imagen en escala de grises")
plt.axis('off')
plt.show()

# Aplicar segmentaci√≥n por umbralizaci√≥n
# Probe distintos valores de 'umbral' (entre 0 y 255) para ver cu√°l separa mejor los objetos del fondo
umbrales = [50, 100, 150, 180, 200]

plt.figure(figsize=(15, 5))

for i, u in enumerate(umbrales):
    _, img_umbral = cv2.threshold(imagen_gris, u, 255, cv2.THRESH_BINARY)
    plt.subplot(1, 5, i + 1)
    plt.imshow(img_umbral, cmap='gray')
    plt.title(f"Umbral = {u}")
    plt.axis('off')

plt.tight_layout()
plt.show()

# Supongamos que ya tenemos:
# imagen_trabajo -> imagen original
# imagen_gris -> versi√≥n en escala de grises
# imagen_umbral -> m√°scara binaria (resultado del umbral elegido)

plt.figure(figsize=(15, 5))

# Imagen original
plt.subplot(1, 3, 1)
plt.imshow(imagen_trabajo)
plt.title("Original")
plt.axis('off')

# Escala de grises
plt.subplot(1, 3, 2)
plt.imshow(imagen_gris, cmap='gray')
plt.title("Escala de grises")
plt.axis('off')

# M√°scara binaria
plt.subplot(1, 3, 3)
plt.imshow(imagen_umbral, cmap='gray')
plt.title("M√°scara umbral")
plt.axis('off')

plt.tight_layout()
plt.show()

"""## 4.2 Mejora de Calidad

**Material de consulta:** `Mejora_Imagen_Ecualizacion.ipynb`
"""

# ‚úÖ Aplicar ecualizaci√≥n de histograma si hay problemas de contraste
# Solo se aplica sobre la imagen en escala de grises
imagen_ecualizada = cv2.equalizeHist(imagen_gris)

# Mostrar comparaci√≥n: original vs ecualizada
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(imagen_gris, cmap='gray')
plt.title("Original (gris)")
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(imagen_ecualizada, cmap='gray')
plt.title("Ecualizada")
plt.axis('off')

plt.tight_layout()
plt.show()

# Supongamos que imagen_trabajo es la imagen que est√° rotada
# Angulo de rotaci√≥n (en grados). Ajust√° seg√∫n necesites
angulo = -90  # negativo = rotaci√≥n en sentido horario

# Obtener dimensiones de la imagen
(h, w) = imagen_trabajo.shape[:2]
centro = (w // 2, h // 2)

# Matriz de rotaci√≥n
M = cv2.getRotationMatrix2D(centro, angulo, 1.0)  # escala=1.0

# Aplicar transformaci√≥n af√≠n (rotaci√≥n)
imagen_corregida = cv2.warpAffine(imagen_trabajo, M, (w, h))

# Mostrar comparaci√≥n
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(imagen_trabajo)
plt.title("Original (rotada)")
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(imagen_corregida)
plt.title("Corregida")
plt.axis('off')

plt.tight_layout()
plt.show()

"""## 4.3 Comparaci√≥n de Resultados"""

# Supongamos que:
# imagen_trabajo -> imagen original
# imagen_procesada -> imagen despu√©s de rotaci√≥n, ecualizaci√≥n o umbralizaci√≥n

plt.figure(figsize=(10, 5))

# Imagen original
plt.subplot(1, 2, 1)
plt.imshow(imagen_trabajo)
plt.title("Original")
plt.axis('off')

# Imagen procesada
plt.subplot(1, 2, 2)
plt.imshow(imagen_procesada, cmap='gray')  # si es binaria o gris
plt.title("Procesada")
plt.axis('off')

plt.tight_layout()
plt.show()

"""## 4.4 Aplicaci√≥n a las Otras Im√°genes

Repet√≠ el proceso para tus otras 2 im√°genes, adaptando las t√©cnicas seg√∫n los problemas espec√≠ficos de cada una:
"""

# Funci√≥n para procesar cada imagen
def procesar_imagen(img, nombre, umbral=120, angulo_rotacion=0, aplicar_ecualizacion=False):
    """
    Procesa una imagen seg√∫n sus problemas espec√≠ficos.

    Par√°metros:
    - img: imagen original
    - nombre: t√≠tulo para visualizaci√≥n
    - umbral: valor para umbralizaci√≥n
    - angulo_rotacion: grados para corregir rotaci√≥n
    - aplicar_ecualizacion: True si se necesita mejorar contraste
    """
    # 1Ô∏è‚É£ Corregir rotaci√≥n si hace falta
    if angulo_rotacion != 0:
        (h, w) = img.shape[:2]
        centro = (w // 2, h // 2)
        M = cv2.getRotationMatrix2D(centro, angulo_rotacion, 1.0)
        img = cv2.warpAffine(img, M, (w, h))

    # 2Ô∏è‚É£ Convertir a escala de grises
    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    # 3Ô∏è‚É£ Ecualizar si hace falta
    if aplicar_ecualizacion:
        img_gray = cv2.equalizeHist(img_gray)

    # 4Ô∏è‚É£ Umbralizaci√≥n
    _, img_umbral = cv2.threshold(img_gray, umbral, 255, cv2.THRESH_BINARY)

    # 5Ô∏è‚É£ Mostrar resultados lado a lado
    plt.figure(figsize=(12, 5))

    plt.subplot(1, 3, 1)
    plt.imshow(img)
    plt.title(f"{nombre} - Original")
    plt.axis('off')

    plt.subplot(1, 3, 2)
    plt.imshow(img_gray, cmap='gray')
    plt.title(f"{nombre} - Gris/Ecualizada")
    plt.axis('off')

    plt.subplot(1, 3, 3)
    plt.imshow(img_umbral, cmap='gray')
    plt.title(f"{nombre} - Umbral")
    plt.axis('off')

    plt.tight_layout()
    plt.show()

    return img_gray, img_umbral

# üîπ Procesar las otras dos im√°genes
# Ajust√° los par√°metros seg√∫n cada caso (rotaci√≥n, contraste, umbral)
procesar_imagen(imagenes[1], nombres[1], umbral=130, angulo_rotacion=-90, aplicar_ecualizacion=False)
procesar_imagen(imagenes[2], nombres[2], umbral=100, angulo_rotacion=0, aplicar_ecualizacion=True)

# Seleccionar la tercera imagen
imagen_trabajo = imagenes[2]
nombre = nombres[2]

# 1Ô∏è‚É£ Convertir a escala de grises
imagen_gris = cv2.cvtColor(imagen_trabajo, cv2.COLOR_RGB2GRAY)

# 2Ô∏è‚É£ Ecualizar para mejorar contraste
imagen_ecualizada = cv2.equalizeHist(imagen_gris)

# 3Ô∏è‚É£ Aplicar umbralizaci√≥n
umbral = 100  # ajusta seg√∫n necesites
_, imagen_umbral = cv2.threshold(imagen_ecualizada, umbral, 255, cv2.THRESH_BINARY)

# 4Ô∏è‚É£ Mostrar resultados: original, gris/ecualizada, m√°scara
plt.figure(figsize=(12, 5))

plt.subplot(1, 3, 1)
plt.imshow(imagen_trabajo)
plt.title(f"{nombre} - Original")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(imagen_ecualizada, cmap='gray')
plt.title(f"{nombre} - Gris/Ecualizada")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(imagen_umbral, cmap='gray')
plt.title(f"{nombre} - Umbral")
plt.axis('off')

plt.tight_layout()
plt.show()

"""## 4.5 Resultados Finales"""

# Supongamos que tenemos:
# imagenes -> lista de im√°genes originales
# nombres -> nombres de cada imagen
# imagenes_procesadas -> lista de im√°genes procesadas (grises/umbralizadas)

# Crear lista de im√°genes procesadas para este ejemplo
imagenes_procesadas = []

# Procesar cada imagen seg√∫n su caso (rotaci√≥n, ecualizaci√≥n, umbralizaci√≥n)
# Ajusta par√°metros seg√∫n cada imagen
for i, img in enumerate(imagenes):
    # Par√°metros de ejemplo, ajustables seg√∫n cada imagen
    if i == 0:  # Buena calidad
        angulo = 0
        ecualizar = False
        umbral = 120
    elif i == 1:  # Rotada
        angulo = -90
        ecualizar = False
        umbral = 130
    else:       # Problemas de contraste
        angulo = 0
        ecualizar = True
        umbral = 100

    # Corregir rotaci√≥n si aplica
    if angulo != 0:
        (h, w) = img.shape[:2]
        centro = (w // 2, h // 2)
        M = cv2.getRotationMatrix2D(centro, angulo, 1.0)
        img = cv2.warpAffine(img, M, (w, h))

    # Escala de grises
    img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    # Ecualizar si aplica
    if ecualizar:
        img_gray = cv2.equalizeHist(img_gray)

    # Umbralizaci√≥n
    _, img_umbral = cv2.threshold(img_gray, umbral, 255, cv2.THRESH_BINARY)

    # Guardar la versi√≥n procesada
    imagenes_procesadas.append(img_umbral)

# üìä Mostrar grid: 2 filas x 3 columnas
plt.figure(figsize=(15, 8))

for i in range(3):
    # Imagen original
    plt.subplot(2, 3, i + 1)
    plt.imshow(imagenes[i])
    plt.title(f"Original - {nombres[i]}")
    plt.axis('off')

    # Imagen procesada
    plt.subplot(2, 3, i + 4)
    plt.imshow(imagenes_procesadas[i], cmap='gray')
    plt.title(f"Procesada - {nombres[i]}")
    plt.axis('off')

plt.tight_layout()
plt.show()

"""---

# REFLEXI√ìN FINAL

## An√°lisis de Resultados

**¬øQu√© t√©cnica fue m√°s efectiva para cada tipo de problema?**

[COMPLETAR: Reflexion√° sobre qu√© funcion√≥ mejor para cada imagen]

**¬øQu√© desaf√≠os encontraste durante el procesamiento?**

[COMPLETAR: Mencion√° las dificultades t√©cnicas que tuviste]

**¬øEn qu√© casos los resultados no fueron √≥ptimos y por qu√©?**

[COMPLETAR: S√© cr√≠tico con tus resultados]

## Aprendizaje Adquirido

**¬øQu√© conceptos del curso fueron m√°s √∫tiles?**

[COMPLETAR: Conect√° con el material visto en clase]

**¬øC√≥mo podr√≠as mejorar este sistema en futuras versiones?**

[COMPLETAR: Pens√° en extensiones posibles]

---

## Entregables

1. Este notebook completamente ejecutado con resultados
2. Carpeta `dataset/` con tus 3 im√°genes
3. Las reflexiones completadas

**Fecha de entrega:** 24 de Septiembre, 23:59

---
"""